package com.example.photoweather;

import android.app.Application;
import android.net.Uri;
import android.os.AsyncTask;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;

import com.example.photoweather.models.Photo;
import com.example.photoweather.models.Weather;

import java.util.List;

import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;
import retrofit2.internal.EverythingIsNonNull;

/**
 * @author Ali Adel
 * <p>
 * Repository to get data for ViewModels without them knowing how data is stored
 * or gotten from network
 * <p>
 * Using Singleton Pattern so only 1 repository instance is used throughout the entire application
 */
public class Repository {

    // Base URL of site to get weather info from
    private static final String BASE_URL = "https://api.openweathermap.org/";
    // App id used to get authorization from API but can only make 60 calls per minute
    // if it makes more it will be blocked
    private static final String APP_ID = "324bcf04cbeda7126c6c1207df0407b2";

    // weather live data that needs to be observed from activities and fragments
    private MutableLiveData<Weather> mWeather = new MutableLiveData<>();
    // API that retrofit generates functions for to use to use API of website
    private WeatherApi mApi;

    // DB interface to use DB operations generated by Room
    private PhotoDao mPhotoDao;
    // live data of all photos in DB to be observed by activites and fragments
    private LiveData<List<Photo>> mAllPhotos;

    // instance of repository because implementing Singleton Pattern
    private static Repository mInstance;

    // instance of application context
    private Application mApplication;

    /**
     * private constructor to not allow anyone to instance new Repository
     *
     * @param application to use to generate DB
     */
    private Repository(Application application) {
        // instantiate Retrofit instance to use network operations
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build();

        // get reference to application context
        mApplication = application;

        // get API from retrofit
        mApi = retrofit.create(WeatherApi.class);

        // get database instance
        PhotoDatabase photoDatabase = PhotoDatabase.getInstance(application);
        // get Dao instance to use interface that Room generates to interact with DB
        mPhotoDao = photoDatabase.photoDao();
        // get all photos live data to observe any change in DB
        mAllPhotos = mPhotoDao.getAllPhotos();
    }

    /**
     * Synchronized to not allow the chance of more than one thread calling at same time
     * and make multiple instance of repository
     * <p>
     * Static to Implement Singleton pattern to only allow 1 instance of Repository throughout
     * all application
     *
     * @param application to use to initialize Repository to initialize DB
     * @return single instance of Repository to be used the entire Application
     */
    public static synchronized Repository getRepositoryInstance(Application application) {
        if (mInstance == null) {
            mInstance = new Repository(application);
        }
        return mInstance;
    }

    /**
     * @return live data to observe weather info that we get from Network API
     */
    public LiveData<Weather> getWeather() {
        return mWeather;
    }

    /**
     * called by live data to make network call and get new weather data
     *
     * @param cityName to query network to get weather information for that city
     */
    public void updateWeather(String cityName) {
        // get API function first and provide it parameters of app id and city to get info of
        Call<Weather> request = mApi.getWeather(APP_ID, cityName);
        // then tell retrofit to make the network call and attach the callback for when response returns
        request.enqueue(new Callback<Weather>() {
            @EverythingIsNonNull
            @Override
            public void onResponse(Call<Weather> call, Response<Weather> response) {
                // if response is successful then change live data for activities and fragments to
                // be notified and update their UI accordingly
                if (response.isSuccessful())
                    mWeather.setValue(response.body());
                else
                    mWeather.setValue(null);
                // if response is failed then update live data with null for UI to know that there
                // was a problem with network request and inform user
            }

            @EverythingIsNonNull
            @Override
            public void onFailure(Call<Weather> call, Throwable t) {
                // in case request failed totally then inform UI that request failed to inform user
                mWeather.setValue(null);
            }
        });
    }


    /**
     * uses async task to not do DB operations on main thread (UI thread)
     * inserts photo in DB
     *
     * @param photo to be inserted in DB
     */
    public void insert(Photo photo) {
        new InsertPhotoAsyncTask(mPhotoDao).execute(photo);
    }


    /**
     * uses async task to not do DB operations on main thread (UI thread)
     * deletes photo from DB
     *
     * @param photo to be deleted from DB
     */
    public void delete(Photo photo) {
        new DeletePhotoAsyncTask(mPhotoDao, mApplication).execute(photo);
    }

    /**
     * uses async task to not do DB operations on main thread (UI thread)
     * deletes all photos from DB
     */
    public void deleteAllPhotos() {
        new DeleteAllPhotosAsyncTask(mPhotoDao, mApplication, mAllPhotos.getValue()).execute();
    }

    /**
     * @return live data that observes DB to know when any change occurred in DB
     */
    public LiveData<List<Photo>> getAllPhotos() {
        return mAllPhotos;
    }

    /**
     * Async task to insert photo in DB to not block main thread with expensive DB operation
     */
    private static class InsertPhotoAsyncTask extends AsyncTask<Photo, Void, Void> {

        // to hold Dao interface to be able to make DB operations
        private PhotoDao mPhotoDao;

        /**
         * made to get instance of Dao interface of DB
         *
         * @param photoDao that holds interface of DB operations
         */
        private InsertPhotoAsyncTask(PhotoDao photoDao) {
            this.mPhotoDao = photoDao;
        }

        // do DB operation
        @Override
        protected Void doInBackground(Photo... photos) {
            mPhotoDao.insert(photos[0]);
            return null;
        }
    }


    /**
     * Async task to delete photo from DB to not block main thread with expensive DB operation
     */
    private static class DeletePhotoAsyncTask extends AsyncTask<Photo, Void, Void> {

        // to hold Dao interface to be able to make DB operations
        private PhotoDao mPhotoDao;
        // reference to application context
        private Application mApplication;

        /**
         * made to get instance of Dao interface of DB
         *
         * @param photoDao that holds interface of DB operations
         */
        private DeletePhotoAsyncTask(PhotoDao photoDao, Application application) {
            this.mPhotoDao = photoDao;
            this.mApplication = application;
        }

        // do DB operation
        @Override
        protected Void doInBackground(Photo... photos) {
            // first delete image from gallery
            try {
                mApplication.getContentResolver().delete(Uri.parse(photos[0].getUrl()), null, null);
            } catch (Exception e) {
                e.printStackTrace();
            }

            // delete it from DB
            mPhotoDao.delete(photos[0]);
            return null;
        }
    }

    /**
     * Async task to delete all photos from DB to not block main thread with expensive DB operation
     */
    private static class DeleteAllPhotosAsyncTask extends AsyncTask<Void, Void, Void> {

        // to hold Dao interface to be able to make DB operations
        private PhotoDao mPhotoDao;
        // reference to application context
        private Application mApplication;
        // list of photos in DB
        private List<Photo> mPhotos;

        /**
         * made to get instance of Dao interface of DB
         *
         * @param photoDao that holds interface of DB operations
         */
        private DeleteAllPhotosAsyncTask(PhotoDao photoDao, Application application, List<Photo> photos) {
            this.mPhotoDao = photoDao;
            this.mApplication = application;
            this.mPhotos = photos;
        }

        // do DB operation
        @Override
        protected Void doInBackground(Void... voids) {

            // if no photos in first place just return and do nothing
            if (mPhotos == null)
                return null;

            // delete from gallery
            for (Photo photo : mPhotos) {
                try {
                    mApplication.getContentResolver().delete(Uri.parse(photo.getUrl()), null, null);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            // delete from DB
            mPhotoDao.deleteAllPhotos();
            return null;
        }
    }

}
